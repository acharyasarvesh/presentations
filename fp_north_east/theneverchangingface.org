#+OPTIONS: toc:nil num:nil
#+OPTIONS: reveal_width:1200
#+OPTIONS: reveal_height:800
#+TITLE: The Never Changing Face of Immutability
#+AUTHOR: Chris Howe-Jones
#+EMAIL: @agile_geek
#+DATE:  15th December 2015
#+REVEAL_SLIDE_NUMBER: false
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.4
#+REVEAL_MAX_SCALE: 2.5
#+OPTIONS: reveal_center:nil
#+OPTIONS: reveal_rolling_links:t reveal_keyboard:t reveal_overview:t
#+REVEAL_THEME: moon
#+REVEAL_TRANS: convex
#+REVEAL_HLEVEL: 2
#+REVEAL_CENTER: true
#+REVEAL_ROOT: reveal.js
#+REVEAL_PLUGINS: (markdown notes)

* Warning!!

   There will be a Lisp!
   There will be Entomology!
   There will be History!
#+BEGIN_NOTES
  * 1st law of Clojure talks
  * Any talk with Clojure in it must have some entomology
#+END_NOTES


* The Never Changing Face of Immutability

   [[./immutable-defined.png]]

*** Who am I?

   Name:      =Chris Howe-Jones=

   Job Title: =Technical Navigator=

   Twitter:   =@agile_geek=

   Github:    =github.com/chrishowejones=

   Blog:      =chrishowejones.wordpress.com=

*** Credentials

   * 28 years of pushing data around
   * Procedural/OOP/FP
   * Architecture & Design
   * RAD/Agile/Lean
   * CTO

** History Lesson

   [[./John-McCarthy.jpg]]

#+BEGIN_NOTES
  * Who is this?
  * John McCarthy
     - developed Lisp
     - influenced design of ALGOL
     - invented GC
     - created term AI
     - first to suggest publicly the idea of utility computing
     - credited with developing an early form of time-sharing
#+END_NOTES

** Once upon a time..

   [[./book-keepers.jpg]]

   Book Keeping
#+ATTR_REVEAL: :frag (roll-in)
   * List of entries in a ledger
#+ATTR_REVEAL: :frag (roll-in)
   * No 'crossing out'!

*** Dawn of Computing

   [[./EDSAC.jpg]]

   * Math
   * Transient storage

#+BEGIN_NOTES
   * EDSAC - Electronic Delay Storage Automatic Calculator
   * Cambridge 1949 - early general purpose electronic programmable computer (ENIAC 1946 was 1st)
   * Storage - mecury delay lines, derated vacuum tubes for logic
   * n 1950, M. V. Wilkes and Wheeler used EDSAC to solve a differential equation relating to gene frequencies in a paper by Ronald Fisher. This represents the first use of a computer for a problem in the field of biology.
   * In 1951, Miller and Wheeler used the machine to discover a 79-digit prime – the largest known at the time.
   * In 1952, Sandy Douglas developed OXO, a version of noughts and crosses (tic-tac-toe) for the EDSAC, with graphical output to a VCR97 6" cathode ray tube. This may well have been the world's first video game.
#+END_NOTES

*** 60's-90's

    [[./1960s-computer.jpg]]

  * Spot the expense?
#+ATTR_REVEAL: :frag (roll-in)
  * Memory
#+ATTR_REVEAL: :frag (roll-in)
  * Tape
#+ATTR_REVEAL: :frag (roll-in)
  * Disk


*** 21st Century

   [[./pair-programming.png]]

   Spot the expense?
#+ATTR_REVEAL: :frag (roll-in)
  * Developers
#+ATTR_REVEAL: :frag (roll-in)
  Cheap resources: SSD/Disk, Memory, CPU


** And..

   [[./fry-so.jpg]]

*** In place computing

   [[./core_memory.jpg]]

#+ATTR_REVEAL: :frag (roll-in)
  * Update data in place
#+ATTR_REVEAL: :frag (roll-in)
  * Reuse expensive real estate

#+BEGIN_NOTES
  * Magnetic core memory 1955-75
  * Core uses tiny magnetic toroids (rings), the cores, through which wires are threaded to write and read information.
  * Each core represents one bit of information.
  * Magnetized in 2 directions (clockwise/counterclockwise) to represent 1 or 0
#+END_NOTES

*** RDBMS

   [[./disk-pack.jpg]]

#+ATTR_REVEAL: :frag (roll-in)
   * Data updated
#+ATTR_REVEAL: :frag (roll-in)
   * Values overwritten
#+ATTR_REVEAL: :frag (roll-in)
   * Reuse memory and disk

#+BEGIN_NOTES
   * Disk pack - invented 1965
   * IBM Engineers - Thomas G. Leary and R. E. Pattison
   * Probably about 50MB on this one.
#+END_NOTES

** Result?

In place computing relies on...

*** Mutation

   [[./mutation.jpg]]

*** Which leads to..

   [[./complect.png]]

*** Complect

   [[./plaiting.jpg]]

#+ATTR_REVEAL: :frag (roll-in)
   * Complecting Identity & Value
#+ATTR_REVEAL: :frag (roll-in)
   * Especially RDBMS, OOP
#+ATTR_REVEAL: :frag (roll-in)
   * Pessimistic concurrency strategies

** Immutability (and values) to the rescue!

   [[./lambda_man.jpg]]

*** Structural Sharing

   [[./clojure-persistent-data-structures-sharing.png]]

   * More efficient memory management
   * persistent bit-partitioned vector trie
   * 32 node tries
   * Wide shallow trees

** What does it look like?

   * Immutable by default
   * Explicit state change

*** ClojureScript on the client

#+BEGIN_SRC clojure
    (defonce state
      (atom
       {:event {:name "event"
                :description ""
                :location {:street-address ""
                           :postcode ""}
                :date ""
                :start-time ""
                :end-time ""
                :speaker ""} :saved? false}))
#+END_SRC
#+REVEAL: split

#+BEGIN_SRC clojure
  (defn new-event-form
    "Render a form to enter a new event."
    []
    (let [event-state (atom {:name ""
                             :description ""
                             :location {:street-address "" :postcode ""}
                             :date ""
                             :start-time ""
                             :end-time ""
                             :speaker ""})]
      (fn []
        [:div
         {:style {:display :flex
                  :margin "20px"
                  :flex-direction :column
                  :align-items :center}}
         [text-input :name event-state "Event name" [:name]]
         [text-area :description event-state]
         [location-input :location event-state]
         [text-input :date event-state]
         [text-input :start-time event-state]
         [text-input :end-time event-state]
         [text-input :speaker event-state]
         [:div
          {:style {:display :flex
                   :margin "20px"
                   :flex-direction :column
                   :align-items :center}}
          [:button.btn.btn-success
           {:on-click
            (fn [_]
              (go (>! event-channel @event-state)))}
           "Create"]]])))
#+END_SRC

#+REVEAL: split

#+BEGIN_SRC clojure
  (defonce save-event
    (go-loop []
      (let [event (<! event-channel)]
        (swap! state assoc :event event)
        (post-event event)
        (recur))))
#+END_SRC
#+BEGIN_SRC clojure
  (defn post-event
    "Post a new event to the server."
    [event]
    (ajax/POST "/q"
               {:params          {:type  :create-event
                                  :event event}
                :handler         (fn [response]
                                   (set! (.-hash (.-location js/window))
                                     (str "/event/" (response "id"))))
                :error-hander    (fn [& args] (println "NOT OK" args))
                :format          (ajax/json-request-format)
                :response-format (ajax/json-response-format)}))
#+END_SRC


*** Efficiency

   [[./todomvc-perf-comparison.png]]

** Clojure on the server

#+BEGIN_SRC clojure
  (defn- handle-query
    [db-conn]
    (fn [{req-body :body-params}]
      {:body (case (:type req-body)
               :get-events (data/get-events db-conn)
               :create-event (data/create-entity db-conn (:txn-data req-body)))
       :create-user  (data/create-entity db-conn (:txn-data req-body))}))

  (defn app [dbconn]
    (-> (routes
         (GET "/" [] home-page)
         (POST "/q" []
               (handle-query dbconn))
         (resources "/"))
        (wrap-restful-format :formats [:edn :transit-json])
        (rmd/wrap-defaults (-> rmd/site-defaults
                               (assoc-in [:security :anti-forgery] false)))))
#+END_SRC

*** Persistence

#+BEGIN_SRC clojure
  (defn create-entity
    "Takes transaction data and returns the resolved tempid"
    [con tx-data]
    (let [had-id (contains? tx-data ":db/id")
          data-with-id (if had-id
                         tx-data
                         (assoc tx-data :db/id #db/id[:db.part/user -1000001]))
          tx @(d/transact con [data-with-id])]
      (if had-id (tx-data ":db/id")
          (d/resolve-tempid (d/db con) (:tempids tx)
                            (d/tempid :db.part/user -1000001)))))
#+END_SRC

** Datomic for Data

   [[./datomic-architecture.png]]

   * App get's its own query, comms, memory- Each App is a peer

#+BEGIN_NOTES
   * Apps are peers
   * Transactor broadcasts txns to peers
   * Peers cache data locally
#+END_NOTES

*** Database as a value

    | Entity | Attribute | Value   | Time       |
    |--------+-----------+---------+------------|
    | Fiona  | likes     | Ruby    | 01/06/2015 |
    | Dave   | likes     | Haskell | 25/09/2015 |
    | Fiona  | likes     | Clojure | 15/12/2015 |
    |        |           |         |            |
    |--------+-----------+---------+------------|
    |        |           |         |            |

   * Effectively DB is local
   * Datalog query language
#+BEGIN_SRC clojure
[:find ?e :where [?e :likes “Clojure”]]
#+END_SRC

#+BEGIN_NOTES
   * Ask connection for database - it returns a value representing the db
   * This is because datoms are immutable - new versions thru time
   * Can invoke your own code from query engine as data is just normal data structures (lists, maps, etc.)
#+END_NOTES

*** Schema

#+BEGIN_SRC clojure
   ;;event
   {
    :db/id                 #db/id[:db.part/db]
    :db/ident              :event/name
    :db/cardinality        :db.cardinality/one
    :db/valueType          :db.type/string
    :db/unique             :db.unique/identity
    :db.install/_attribute :db.part/db
    }
   {
    :db/id                 #db/id[:db.part/db]
    :db/ident              :event/description
    :db/cardinality        :db.cardinality/one
    :db/valueType          :db.type/string
    :db.install/_attribute :db.part/db
    }
   {
    :db/id                 #db/id[:db.part/db]
    :db/ident              :event/location
    :db/cardinality        :db.cardinality/one
    :db/valueType          :db.type/ref
    :db.install/_attribute :db.part/db
    }
  ...
#+END_SRC
#+REVEAL: split
#+BEGIN_SRC clojure
  ;;location
   {
    :db/id                 #db/id[:db.part/db]
    :db/ident              :location/postCode
    :db/cardinality        :db.cardinality/one
    :db/valueType          :db.type/string
    :db.install/_attribute :db.part/db
    }
   {
    :db/id                 #db/id[:db.part/db]
    :db/ident              :location/description
    :db/cardinality        :db.cardinality/one
    :db/valueType          :db.type/string
    :db.install/_attribute :db.part/db
    }
  ...
#+END_SRC

#+BEGIN_NOTES
    * History
      - book keeping - double entry. Didn't change in place.
      - 50's, 60's memory expensive resource (dates? picture of large old machine)
      - Swapping instructions in and out of memory - tape -> disk
      - 70's, 80's and 90's secondary storage expensive - rise of RDBMS
      - memory still reasonably expensive
      - In place computing as resources scarce
      - 00's and 2010's disk cheaper, memory very cheap.
      - in parallel the rise of OOP - objects with data and behaviour
    * Why immutability?
      - What does mutation bring (picture of three eyed fish from Simpsons _ other pop culture references)
      - Can't stand in same river twice (where is origin of quote?)
      - Complecting the concepts of identity and value particularly OO and RDBMS in trad. use.
      - Issues of concurrency. Complex values are changed underneath you.
      - Optimisations - (dig out graph of Om compared with React.js)
    * What does it look like?
      - Examples in:
        + Clojurescript - UI state as a value
        + Clojure - server state as value and a chain of functions
        + Datomic - database as a value - local cache, peer to peer
#+END_NOTES
